Ryan Slyter
10799467
rabemensch@gmail.com

Programming Project 1: Taylor Series with e^x

Files: myexp.c readme.txt relerror.c

For this assignment I wrote a small C program which determines the lowest n in the taylor series that gives an error which is still below machine error, thus allowing us to solve a shorter taylor polynomial, which is then computed in my second C program, myexp.c

For the relative error program it was simple: you compute the relative error with the equations provided by the assignment prompt, store them in a simple array such that the 1st index represents n = 1, etc. (the 0 and 16th werent used because we were analyzing integers 1-15) and then you move downward from the 15th, because the higher n's will obviously give you an awesome error which will stay under the mach error. Once you hit an index which has a relative error stored in it that is higher than the machine error, you know that the previous n is the lowest such n that stays below the machine error. From all of this we can obviously gather that less Taylor terms give you less precision and so one, however we don't want to actually calculate a ridiculously long Taylor series, if an n=7 Taylor series gives you a good approximation (my program found 7 to be the right n to use in the next program).

For the myexp.c program, I simply followed on the breaking down of the e^x function, the different variables u, z, m etc, which use range reduction to simplify the problem into one that only involves addition, multiplication, and rare occurences of division. Note that I kept u, z, m, and w the same as in the assignment prompt for clarity; hopefully this made my code easy to follow. Using Horner's Rule for nested multiplication for an n=7 taylor series was done by hand first, so that there was no need for Horner's actual algorithm to be used; everything was nested and ready to be calculated at run time. I used doubles for all the calculations because long double's for the result were giving me ridiculous relative errors, like -1219878302984309.000 and such which I could not figure out and hopefully will come to understand those problems as the semester goes by. I will not waste any more of your time as you will see by my output and following my code that most of the assignment was straightforward, and as long I correctly did the nesting multiplication by hand using Horner's and then correctly rolled that out in my program, my results were very respectable, usually yielding some number*10-7 or -6. However, one problem was that in the assignment it said that if (m<0) to do 1 << -m and take the reciprical of that, which I did. However, Dr. Cochran said to just take the reciprical, or even more efficiently to use some lexpr(1,m) function. Both of those methods gave me completely wrong answers for when x = negative numbers; so either I didn't understand those correctly or didn't code them in correctly when I tried them out. However, just going by what the assignment prompt said: compute 2^-m (or 1 << -m) and take the reciprical of that worked out just fine.
